"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var contentHash = __importStar(require("content-hash"));
var bip44_constants_1 = __importDefault(require("bip44-constants"));
var address_encoder_1 = require("@ensdomains/address-encoder");
var ethereum_ens_network_map_1 = __importDefault(require("ethereum-ens-network-map"));
var ens_1 = __importDefault(require("./contracts/ens/ens"));
var resolver_1 = __importDefault(require("./contracts/ens/resolver"));
var nameWrapper_1 = __importDefault(require("./contracts/ens/nameWrapper"));
var baseRegistrar_1 = __importDefault(require("./contracts/ens/baseRegistrar"));
var reverseRegistrar_1 = __importDefault(require("./contracts/ens/reverseRegistrar"));
var types_1 = require("./types");
var resolutionError_1 = require("./errors/resolutionError");
var EthereumContract_1 = __importDefault(require("./contracts/EthereumContract"));
var publicTypes_1 = require("./types/publicTypes");
var utils_1 = require("./utils");
var FetchProvider_1 = __importDefault(require("./FetchProvider"));
var namehash_1 = require("./utils/namehash");
var NamingService_1 = require("./NamingService");
var configurationError_1 = __importStar(require("./errors/configurationError"));
var utils_2 = require("./utils");
var ens_config_json_1 = __importDefault(require("./config/ens-config.json"));
var Networking_1 = __importDefault(require("./utils/Networking"));
/**
 * @internal
 */
var Ens = /** @class */ (function (_super) {
    __extends(Ens, _super);
    function Ens(source) {
        var _this = _super.call(this) || this;
        _this.name = publicTypes_1.NamingServiceName.ENS;
        var finalSource = { url: '', network: 'mainnet' };
        if (source) {
            finalSource = _this.checkNetworkConfig(source);
        }
        _this.network = utils_2.EthereumNetworks[finalSource.network];
        _this.networkName = finalSource.network;
        _this.url = finalSource['url'];
        _this.provider =
            finalSource['provider'] ||
                FetchProvider_1.default.factory(publicTypes_1.NamingServiceName.ENS, _this.url);
        _this.proxyServiceApiKey = finalSource['proxyServiceApiKey'];
        var registryAddress = finalSource['registryAddress'] || ethereum_ens_network_map_1.default[_this.network];
        _this.registryContract = new EthereumContract_1.default(ens_1.default, registryAddress, _this.provider, _this.proxyServiceApiKey);
        var nameWrapperAddress = _this.determineNameWrapperAddress(_this.network);
        _this.nameWrapperContract = new EthereumContract_1.default(nameWrapper_1.default, nameWrapperAddress, _this.provider, _this.proxyServiceApiKey);
        var baseRegistrarAddress = _this.determineBaseRegistrarAddress(_this.network);
        _this.baseRegistrarContract = new EthereumContract_1.default(baseRegistrar_1.default, baseRegistrarAddress, _this.provider, _this.proxyServiceApiKey);
        return _this;
    }
    Ens.autoNetwork = function (config) {
        return __awaiter(this, void 0, void 0, function () {
            var provider, networkId, networkName;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if ((0, types_1.hasProvider)(config)) {
                            provider = config.provider;
                        }
                        else {
                            if (!config.url) {
                                throw new configurationError_1.default(configurationError_1.ConfigurationErrorCode.UnspecifiedUrl, {
                                    method: publicTypes_1.NamingServiceName.ENS,
                                });
                            }
                            provider = FetchProvider_1.default.factory(publicTypes_1.NamingServiceName.ENS, config.url);
                        }
                        return [4 /*yield*/, provider.request({
                                method: 'net_version',
                            })];
                    case 1:
                        networkId = (_a.sent());
                        networkName = utils_1.EthereumNetworksInverted[networkId];
                        if (!networkName || !types_1.EnsSupportedNetwork.guard(networkName)) {
                            throw new configurationError_1.default(configurationError_1.ConfigurationErrorCode.UnsupportedNetwork, {
                                method: publicTypes_1.NamingServiceName.ENS,
                            });
                        }
                        return [2 /*return*/, new this({ network: networkName, provider: provider })];
                }
            });
        });
    };
    Ens.prototype.serviceName = function () {
        return this.name;
    };
    Ens.prototype.namehash = function (domain) {
        if (!this.checkSupportedDomain(domain)) {
            throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.UnsupportedDomain, {
                domain: domain,
            });
        }
        return (0, namehash_1.eip137Namehash)(domain);
    };
    Ens.prototype.childhash = function (parentHash, label) {
        return (0, namehash_1.eip137Childhash)(parentHash, label);
    };
    Ens.prototype.isSupportedDomain = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.checkSupportedDomain(domain)];
            });
        });
    };
    Ens.prototype.owner = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            var namehash, isWrapped;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        namehash = this.namehash(domain);
                        return [4 /*yield*/, this.determineIsWrappedDomain(namehash)];
                    case 1:
                        isWrapped = _a.sent();
                        if (!isWrapped) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.callMethod(this.nameWrapperContract, 'ownerOf', [
                                namehash,
                            ])];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3: return [4 /*yield*/, this.callMethod(this.registryContract, 'owner', [namehash])];
                    case 4: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    Ens.prototype.resolver = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            var nodeHash, resolverAddr;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        nodeHash = this.namehash(domain);
                        return [4 /*yield*/, this.callMethod(this.registryContract, 'resolver', [nodeHash])];
                    case 1:
                        resolverAddr = _a.sent();
                        if ((0, utils_1.isNullAddress)(resolverAddr)) {
                            throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.UnspecifiedResolver);
                        }
                        return [2 /*return*/, resolverAddr];
                }
            });
        });
    };
    Ens.prototype.record = function (domain, key) {
        return __awaiter(this, void 0, void 0, function () {
            var returnee;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getTextRecord(domain, key)];
                    case 1:
                        returnee = _a.sent();
                        if (!returnee) {
                            throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.RecordNotFound, {
                                domain: domain,
                                recordName: key,
                                method: this.name,
                                methodName: 'record',
                            });
                        }
                        return [2 /*return*/, returnee];
                }
            });
        });
    };
    Ens.prototype.records = function (domain, keys) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.UnsupportedMethod, {
                    methodName: 'records',
                    domain: domain,
                    method: this.serviceName(),
                });
            });
        });
    };
    // TODO: Need to understand how ENS supports DNS @see https://docs.ens.domains/contract-api-reference/dns-registrar#retrieving-the-dns-text-record
    Ens.prototype.dns = function (domain, types) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.UnsupportedMethod, {
                    methodName: 'dns',
                    method: this.serviceName(),
                    domain: domain,
                });
            });
        });
    };
    Ens.prototype.reverse = function (address, currencyTicker) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.UnsupportedMethod, {
                    methodName: 'reverse',
                });
            });
        });
    };
    // TODO: Figure out why nameHash() does not work for reverse address.
    // Current implementation uses reverseRegistrarContract to fetch the correct node hash.
    // @see: https://eips.ethereum.org/EIPS/eip-181
    Ens.prototype.reverseOf = function (address) {
        return __awaiter(this, void 0, void 0, function () {
            var originalAddress, reverseRegistrarAddress, reverseRegistrarContract, nodeHash, resolverAddress, resolverContract, domainName, fetchedAddress;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        originalAddress = address;
                        if (address.startsWith('0x')) {
                            address = address.substr(2);
                        }
                        reverseRegistrarAddress = this.determineReverseRegistrarAddress(this.network);
                        reverseRegistrarContract = new EthereumContract_1.default(reverseRegistrar_1.default, reverseRegistrarAddress, this.provider, this.proxyServiceApiKey);
                        return [4 /*yield*/, this.reverseRegistrarCallToNode(reverseRegistrarContract, address)];
                    case 1:
                        nodeHash = _a.sent();
                        return [4 /*yield*/, this.callMethod(this.registryContract, 'resolver', [nodeHash])];
                    case 2:
                        resolverAddress = _a.sent();
                        if ((0, utils_1.isNullAddress)(resolverAddress)) {
                            return [2 /*return*/, null];
                        }
                        resolverContract = new EthereumContract_1.default((0, resolver_1.default)(resolverAddress, types_1.EthCoinIndex), resolverAddress, this.provider, this.proxyServiceApiKey);
                        return [4 /*yield*/, this.resolverCallToName(resolverContract, nodeHash)];
                    case 3:
                        domainName = _a.sent();
                        return [4 /*yield*/, this.resolverCallToAddr(resolverContract, domainName)];
                    case 4:
                        fetchedAddress = _a.sent();
                        if ((fetchedAddress === null || fetchedAddress === void 0 ? void 0 : fetchedAddress.toLowerCase()) !== originalAddress.toLowerCase()) {
                            return [2 /*return*/, null];
                        }
                        return [2 /*return*/, domainName];
                }
            });
        });
    };
    Ens.prototype.getTokenUri = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            var tokenId, isWrappedDomain, hashedLabel;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tokenId = this.namehash(domain);
                        return [4 /*yield*/, this.determineIsWrappedDomain(tokenId)];
                    case 1:
                        isWrappedDomain = _a.sent();
                        if (isWrappedDomain) {
                            return [2 /*return*/, "https://metadata.ens.domains/".concat(this.networkName, "/").concat(this.nameWrapperContract.address, "/").concat(tokenId)];
                        }
                        hashedLabel = (0, namehash_1.labelNameHash)(domain);
                        return [2 /*return*/, "https://metadata.ens.domains/".concat(this.networkName, "/").concat(this.baseRegistrarContract.address, "/").concat(hashedLabel)];
                }
            });
        });
    };
    Ens.prototype.isAvailable = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.isRegistered(domain)];
                    case 1: return [2 /*return*/, !(_a.sent())];
                }
            });
        });
    };
    Ens.prototype.registryAddress = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.registryContract.address];
            });
        });
    };
    Ens.prototype.isRegistered = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            var address;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.owner(domain)];
                    case 1:
                        address = _a.sent();
                        return [2 /*return*/, !(0, utils_1.isNullAddress)(address)];
                }
            });
        });
    };
    // Tries to fetch domain metadata from both NameWrapper & BaseRegistrar contract
    // due to ENS having wrapped domains and not knowing which hash the user will input.
    Ens.prototype.getDomainFromTokenId = function (hash) {
        return __awaiter(this, void 0, void 0, function () {
            var domainName, nameWrapperMetadataResponse, jsonResponse, baseRegistrarMetadataResponse, jsonResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        domainName = '';
                        return [4 /*yield*/, Networking_1.default.fetch("https://metadata.ens.domains/".concat(this.networkName, "/").concat(this.nameWrapperContract.address, "/").concat(hash), {})];
                    case 1:
                        nameWrapperMetadataResponse = _a.sent();
                        if (!(nameWrapperMetadataResponse.status === 200)) return [3 /*break*/, 3];
                        return [4 /*yield*/, nameWrapperMetadataResponse.json()];
                    case 2:
                        jsonResponse = _a.sent();
                        domainName = jsonResponse.name;
                        return [2 /*return*/, domainName];
                    case 3: return [4 /*yield*/, Networking_1.default.fetch("https://metadata.ens.domains/".concat(this.networkName, "/").concat(this.baseRegistrarContract.address, "/").concat(hash), {})];
                    case 4:
                        baseRegistrarMetadataResponse = _a.sent();
                        if (!(baseRegistrarMetadataResponse.status === 200)) return [3 /*break*/, 6];
                        return [4 /*yield*/, baseRegistrarMetadataResponse.json()];
                    case 5:
                        jsonResponse = _a.sent();
                        domainName = jsonResponse.name;
                        _a.label = 6;
                    case 6: return [2 /*return*/, domainName];
                }
            });
        });
    };
    Ens.prototype.locations = function (domains) {
        return __awaiter(this, void 0, void 0, function () {
            var result, _i, domains_1, domain, _a, _b;
            var _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        result = {};
                        _i = 0, domains_1 = domains;
                        _d.label = 1;
                    case 1:
                        if (!(_i < domains_1.length)) return [3 /*break*/, 5];
                        domain = domains_1[_i];
                        _a = result;
                        _b = domain;
                        _c = {};
                        return [4 /*yield*/, this.getResolverContract(domain)];
                    case 2:
                        _c.resolverAddress = (_d.sent()).address,
                            _c.registryAddress = this.registryContract.address,
                            _c.networkId = this.network,
                            _c.blockchain = publicTypes_1.BlockchainType.ETH;
                        return [4 /*yield*/, this.addr(domain, publicTypes_1.BlockchainType.ETH)];
                    case 3:
                        _a[_b] = (_c.ownerAddress = (_d.sent()) || '',
                            _c.blockchainProviderUrl = this.url,
                            _c);
                        _d.label = 4;
                    case 4:
                        _i++;
                        return [3 /*break*/, 1];
                    case 5: return [2 /*return*/, result];
                }
            });
        });
    };
    Ens.prototype.getAddress = function (domain, network, token) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.UnsupportedMethod, {
                    methodName: 'getAddress',
                    domain: domain,
                    method: this.serviceName(),
                });
            });
        });
    };
    /**
     * This was done to make automated tests more configurable
     */
    Ens.prototype.resolverCallToName = function (resolverContract, nodeHash) {
        return this.callMethod(resolverContract, 'name', [nodeHash]);
    };
    /**
     * This was done to make automated tests more configurable
     */
    Ens.prototype.reverseRegistrarCallToNode = function (reverseRegistrarContract, address) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.callMethod(reverseRegistrarContract, 'node', [address])];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * This was done to make automated tests more configurable
     */
    Ens.prototype.resolverCallToAddr = function (resolverContract, domainName) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.callMethod(resolverContract, 'addr', [
                            this.namehash(domainName),
                        ])];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // @see: https://docs.ens.domains/ens-improvement-proposals/ensip-5-text-records#service-keys
    Ens.prototype.twitter = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            var err_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.record(domain, 'com.twitter')];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2:
                        err_1 = _a.sent();
                        throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.RecordNotFound, {
                            domain: domain,
                            method: this.name,
                            methodName: 'twitter',
                            recordName: err_1.recordName,
                        });
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    Ens.prototype.allRecords = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.UnsupportedMethod, {
                    domain: domain,
                    methodName: 'allRecords',
                });
            });
        });
    };
    Ens.prototype.getCoinType = function (currencyTicker) {
        var coin = bip44_constants_1.default.findIndex(function (item) {
            return item[1] === currencyTicker.toUpperCase() ||
                item[2] === currencyTicker.toUpperCase();
        });
        if (coin < 0 || !address_encoder_1.formatsByCoinType[coin]) {
            throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.UnsupportedCurrency, {
                currencyTicker: currencyTicker,
            });
        }
        return coin.toString();
    };
    Ens.prototype.addr = function (domain, currencyTicker) {
        return __awaiter(this, void 0, void 0, function () {
            var resolver, owner, coinType;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.resolver(domain).catch(function (err) {
                            if (err.code !== resolutionError_1.ResolutionErrorCode.UnspecifiedResolver) {
                                throw err;
                            }
                        })];
                    case 1:
                        resolver = _a.sent();
                        if (!!resolver) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.owner(domain)];
                    case 2:
                        owner = _a.sent();
                        if ((0, utils_1.isNullAddress)(owner)) {
                            throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.UnregisteredDomain, {
                                domain: domain,
                            });
                        }
                        throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.UnspecifiedResolver, {
                            domain: domain,
                        });
                    case 3:
                        coinType = this.getCoinType(currencyTicker.toUpperCase());
                        return [4 /*yield*/, this.fetchAddress(resolver, domain, coinType)];
                    case 4: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    Ens.prototype.fetchAddress = function (resolver, domain, coinType) {
        return __awaiter(this, void 0, void 0, function () {
            var resolverContract, nodeHash, addr, _a, data;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        resolverContract = new EthereumContract_1.default((0, resolver_1.default)(resolver, coinType), resolver, this.provider, this.proxyServiceApiKey);
                        nodeHash = this.namehash(domain);
                        if (!(coinType !== types_1.EthCoinIndex)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.callMethod(resolverContract, 'addr', [nodeHash, coinType])];
                    case 1:
                        _a = _b.sent();
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, this.callMethod(resolverContract, 'addr', [nodeHash])];
                    case 3:
                        _a = _b.sent();
                        _b.label = 4;
                    case 4:
                        addr = _a;
                        if ((0, utils_1.isNullAddress)(addr)) {
                            return [2 /*return*/, undefined];
                        }
                        data = Buffer.from(addr.replace('0x', ''), 'hex');
                        return [2 /*return*/, address_encoder_1.formatsByCoinType[coinType].encoder(data)];
                }
            });
        });
    };
    // @see https://docs.ens.domains/ens-improvement-proposals/ensip-5-text-records
    Ens.prototype.getTextRecord = function (domain, key) {
        return __awaiter(this, void 0, void 0, function () {
            var nodeHash, resolver, textRecord;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(key === 'contenthash')) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.getContentHash(domain)];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2:
                        nodeHash = this.namehash(domain);
                        return [4 /*yield*/, this.getResolverContract(domain)];
                    case 3:
                        resolver = _a.sent();
                        return [4 /*yield*/, this.callMethod(resolver, 'text', [nodeHash, key])];
                    case 4:
                        textRecord = _a.sent();
                        return [2 /*return*/, textRecord];
                }
            });
        });
    };
    // @see https://docs.ens.domains/ens-improvement-proposals/ensip-7-contenthash-field
    Ens.prototype.getContentHash = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            var nodeHash, resolverContract, contentHashEncoded, codec;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        nodeHash = this.namehash(domain);
                        return [4 /*yield*/, this.getResolverContract(domain)];
                    case 1:
                        resolverContract = _a.sent();
                        return [4 /*yield*/, this.callMethod(resolverContract, 'contenthash', [nodeHash])];
                    case 2:
                        contentHashEncoded = _a.sent();
                        codec = contentHash.getCodec(contentHashEncoded);
                        if (codec !== 'ipfs-ns') {
                            return [2 /*return*/, undefined];
                        }
                        return [2 /*return*/, contentHash.decode(contentHashEncoded)];
                }
            });
        });
    };
    Ens.prototype.getResolverContract = function (domain, coinType) {
        return __awaiter(this, void 0, void 0, function () {
            var resolverAddress;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.resolver(domain)];
                    case 1:
                        resolverAddress = _a.sent();
                        return [2 /*return*/, new EthereumContract_1.default((0, resolver_1.default)(resolverAddress, coinType), resolverAddress, this.provider, this.proxyServiceApiKey)];
                }
            });
        });
    };
    Ens.prototype.callMethod = function (contract, method, params) {
        return __awaiter(this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, contract.call(method, params)];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result[0]];
                }
            });
        });
    };
    // Checks if domain is an ENS domain with tlds, or a reverse address.
    Ens.prototype.checkSupportedDomain = function (domain) {
        return (domain === 'eth' ||
            /^([^\s\\.]+\.)+(eth|luxe|xyz|kred)+$/.test(domain) ||
            /^([^\s\\.]+\.)(addr\.)(reverse)$/.test(domain));
    };
    Ens.prototype.checkNetworkConfig = function (source) {
        if (!(source === null || source === void 0 ? void 0 : source.network)) {
            throw new configurationError_1.default(configurationError_1.ConfigurationErrorCode.UnsupportedNetwork, {
                method: this.name,
            });
        }
        if (!types_1.EnsSupportedNetwork.guard(source.network)) {
            this.checkCustomNetworkConfig(source);
        }
        return source;
    };
    Ens.prototype.checkCustomNetworkConfig = function (source) {
        if (!this.isValidRegistryAddress(source.registryAddress)) {
            throw new configurationError_1.default(configurationError_1.ConfigurationErrorCode.InvalidConfigurationField, {
                method: this.name,
                field: 'registryAddress',
            });
        }
        if (!source['url'] && !source['provider']) {
            throw new configurationError_1.default(configurationError_1.ConfigurationErrorCode.CustomNetworkConfigMissing, {
                method: this.name,
                config: 'url or provider',
            });
        }
    };
    Ens.prototype.isValidRegistryAddress = function (address) {
        if (!address) {
            throw new configurationError_1.default(configurationError_1.ConfigurationErrorCode.CustomNetworkConfigMissing, {
                method: this.name,
                config: 'registryAddress',
            });
        }
        var ethLikePattern = new RegExp('^0x[a-fA-F0-9]{40}$');
        return ethLikePattern.test(address);
    };
    Ens.prototype.getAddressForWrappedDomain = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            var addr1, addr2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getOwnerOfFromNameHashContract(domain)];
                    case 1:
                        addr1 = _a.sent();
                        return [4 /*yield*/, this.owner(domain)];
                    case 2:
                        addr2 = _a.sent();
                        if (addr1) {
                            return [2 /*return*/, addr1];
                        }
                        if (addr2) {
                            return [2 /*return*/, addr2];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    Ens.prototype.determineNameWrapperAddress = function (network) {
        return ens_config_json_1.default.networks[network].contracts.NameWrapper.address;
    };
    Ens.prototype.determineBaseRegistrarAddress = function (network) {
        return ens_config_json_1.default.networks[network].contracts.BaseRegistrarImplementation
            .address;
    };
    Ens.prototype.determineReverseRegistrarAddress = function (network) {
        return ens_config_json_1.default.networks[network].contracts.ReverseRegistrar.address;
    };
    Ens.prototype.determineIsWrappedDomain = function (hashedDomain) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.callMethod(this.nameWrapperContract, 'isWrapped', [
                            hashedDomain,
                        ])];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    Ens.prototype.getOwnerOfFromNameHashContract = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.callMethod(this.nameWrapperContract, 'ownerOf', [
                            this.namehash(domain),
                        ])];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    Ens.prototype.getMetadataFromTokenURI = function (tokenUri) {
        return __awaiter(this, void 0, void 0, function () {
            var resp, _a, _b;
            var _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0: return [4 /*yield*/, Networking_1.default.fetch(tokenUri, {})];
                    case 1:
                        resp = _d.sent();
                        if (resp.ok) {
                            return [2 /*return*/, resp.json()];
                        }
                        _a = resolutionError_1.ResolutionError.bind;
                        _b = [void 0, resolutionError_1.ResolutionErrorCode.ServiceProviderError];
                        _c = {};
                        return [4 /*yield*/, resp.text()];
                    case 2: throw new (_a.apply(resolutionError_1.ResolutionError, _b.concat([(_c.providerMessage = _d.sent(),
                            _c.method = 'UDAPI',
                            _c.methodName = 'tokenURIMetadata',
                            _c)])))();
                }
            });
        });
    };
    return Ens;
}(NamingService_1.NamingService));
exports.default = Ens;
